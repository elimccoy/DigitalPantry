import { StyleSheet, View, TouchableOpacity, FlatList, Dimensions } from 'react-native';
import { useState, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { FAB, Subheading } from 'react-native-paper';
import ShoppingListItem from '../../../components/ShoppingListItem.js';
import SuggestedItem from '../../../components/SuggestedItem.js';
import { moveSuggestedToList, editItem, unselectAllItems } from '../../../store/slices/shoppingList';
import CustomNavigationBar from './CustomNavigationBar.js';
import ContextualActionBar from './ContextualActionBar';
import moment from 'moment';

/**
 * Shopping Screen where shopping list and suggested items are displayed. Note: only the shopping list is stored/generated using redux,
 * the suggested items list is generated based on the items currently in the pantry everytime the user navigates to this screen. This 
 * way we avoid having to check for updates and manually deleting or updating suggested items as the list that is generated in this 
 * screen will be based on the current version of the pantry. Users can choose to add, edit, or delete items from this screen.
 */

const ShoppingScreen = ({ navigation }) => {

  const listItems = useSelector((state) => state.shoppingList.list); // get the shopping list from shoppingList.js
  const pantryItems = useSelector((state) => state.pantry.ingredients); // get the current pantry ingredients from pantry.js
  
  /**
   * The suggested items list is generated by going through the pantry items and for each item checking if its remaining amount
   * is 'Low' OR if the item will expire in less than a week from the current date AND also goes through the current listItems and 
   * checks if the item is NOT in the list already. Then we store the data (key, name, ...) of each of those items in suggItems.
   */
  const suggItems = pantryItems.filter((ingredient) => ((ingredient.remaining === 'Low') || (moment(ingredient.expirationDate).diff(Date.now(), 'days') < 7))
    && !(listItems.find((item) => item.key === ingredient.key))).map((suggestedItem) =>
    ({
      key: suggestedItem.key,
      name: suggestedItem.name,
      unit: suggestedItem.unit,
      image: suggestedItem.image,
      brand: suggestedItem.brand,
      description: suggestedItem.description,
      remaining: suggestedItem.remaining,
      amount: suggestedItem.amount,
      expirationDate: suggestedItem.expirationDate,
    }));
  const dispatch = useDispatch();

  const [showFab] = useState(true);
  const [expanded, setExpanded] = useState(true);

  /**
   * this will determine if the ContextualActionBar is to be shown and if the user is currently selecting items or in 'selection mode'
   */
  const [cabIsOpen, setCabIsOpen] = useState(false); 
  const [state, setState] = useState({ open: false });
  const onStateChange = ({ open }) => setState({ open });
  const { open } = state;
  const handlePress = () => setExpanded(!expanded);

  /**
   * Changes the header depending on cabIsOpen
   */
  useEffect(() => { 
    if (cabIsOpen === true) { // if cabIsOpen is set to true that means it needs to be shown and users need to be able to select items
      navigation.setOptions({ // changes header to CAB
        header: (props) => (<ContextualActionBar {...props} close={closeHeader} />),
      });
    } else { // if cabIsOpen is set to false then we want to show the regular header
      navigation.setOptions({ header: (props) => <CustomNavigationBar {...props} /> });
    }
  }, [cabIsOpen]); // when cabIsOpen changes


  const openHeader = () => { // this opens the CAB header, so it sets cabIsOpen to true
    setCabIsOpen(true);
  }

  const closeHeader = () => { // this closes the CAB header, so it sets cabIsOpen to false and deselects all items that were selected
    setCabIsOpen(false);
    dispatch(unselectAllItems()); // since cabIsOpen will now be false, the user is not supposed to be able to select anything so we want to 'reset' the users selections 
  }

  const addAllSuggested = () => { // adds all suggested items to shopping list
    suggItems.map((item) => dispatch(moveSuggestedToList(item)));
  }

  /**
   * Triggered when the user taps on an item. The behavior depends on whether the user is currently selecting items to delete or not. Takes in 
   * item as we need it to either update it or to navigate to its info screen.
   */
  const handleSelect = (item) => {
    /**
     * if the item the user taps on is in shopping list and cabIsOpen is true, then that means that the user is selecting items to delete
     * so we create a new item to update the item's 'checked' attrribute
     */
    if (cabIsOpen === true && listItems.find((listItem) => listItem.key === item.key)) { 
      let newItem = { 
        key: item.key,
        name: item.name,
        unit: item.unit,
        amount: item.amount,
        image: item.image,
        brand: item.brand,
        description: item.description,
        remaining: item.remaining,
        expirationDate: item.expirationDate,
        checked: !(item.checked),
      };

      dispatch(editItem(newItem)); // call the editItem reducer with the new updated item

    } else { // if the user is not selecting items to delete, then that means that they just tapped on the item to view its info
      navigation.navigate("ListItemInfoScreen", { key: item.key }); // navigate to the item's info screen
    }

  }

  /**
   * renderItem for shopping list FlatList. Takes in an item and renders it as a <ShoppingListItem>. If the user long presses on this item they
   * are taken to the edit/delete screen. If they just press/tap of the item the handleSelect is called 
   */
  const renderItem = ({ item }) => {
    return (
      <TouchableOpacity
        style={styles.item}
        onLongPress={() => { if (cabIsOpen === false) { navigation.navigate('ListEditDeleteScreen', { itemToEdit: item }) } }}
        onPress={() => { handleSelect(item) }}
        key={item.key}
      >
        <ShoppingListItem item={item} key={item.key} />
      </TouchableOpacity>
    );
  };

  /**
   * renderSuggestedItem for suggested FlatList. Takes in an item and renders it as a <SuggestedItem> and we also pass the moveSuggestedToList
   * reducer so user can add this item to the shopping list. Nothing happens if the user presses or long-presses on an item. 
   */
  const renderSuggestedItem = ({ item }) => {
    return (
      <TouchableOpacity
        style={styles.item}
        key={item.key}
      >
        <SuggestedItem item={item} key={item.key} addItem={() => dispatch(moveSuggestedToList(item))} />
      </TouchableOpacity>
    );
  };

  /**
   * Renders the shopping and suggested lists. The suggested list is rendered as the shopping list's ListFooterComponent to avoid 
   * warnings/issues with ScrollView and FlatLists. FAB is also rendered and gives user the options to add an item, add all suggested items, or 
   * delete items from the shopping list, with each of these options calling the appropriate function. If the user taps on add an item
   * they are taken to the ListAddScreen, if they tap on add all suggested then addAllSuggested is called, if they tap on delete items 
   * the openHeader function is called.
   */
  return (
    <View style={styles.container}>

      <FlatList
        data={listItems}
        numColumns={2}
        renderItem={renderItem}
        scrollEnabled={true}
        ListFooterComponent={
          <View>

            <View style={styles.subheading}>
              <Subheading style={styles.listTitle}>Suggested:</Subheading>
            </View>
            <FlatList
              data={suggItems}
              numColumns={2}
              renderItem={renderSuggestedItem}
              scrollEnabled={false}
            />
          </View>
        }
      />

      <FAB.Group
        visible={showFab}
        open={open}
        icon={'pencil'}
        style={styles.fab}
        actions={[
          {
            icon: 'plus-circle-outline',
            label: 'Add an item',
            onPress: () => {
              navigation.navigate('ListAddScreen')
            },
          },
          {
            icon: 'plus-circle-multiple-outline',
            label: 'Add all suggested items',
            onPress: () => {
              addAllSuggested();
            },
          },
          {
            icon: 'minus-circle-outline',
            label: 'Delete Shopping items',
            onPress: () => {
              openHeader()
            },
          }

        ]}
        onStateChange={onStateChange}
      />

    </View>

  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    width: "100%",
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: 3,
    elevation: 3,
    shadowColor: '#52006A',
  },
  scollContainer: {
    flex: 1,
  },
  item: {
    alignItems: 'center',
    justifyContent: 'center',
    margin: 5,
    height: Dimensions.get('window').width / 2, // approximate a square
    width: Dimensions.get('window').width / 2 - 10,
  },
  backgroundImgStyle: {
    flex: 1,
    width: '100%',
    justifyContent: 'center',
  },
  backgroundImgStyleImageStyles: {
    borderRadius: 3,
  },
  statusBadge: {
    position: 'absolute',
    bottom: 7,
    left: 7,
    maxWidth: "70%",
  },
  nameBadge: {
    position: 'absolute',
    top: 7,
    right: 7,
    maxWidth: "70%",
  },
  check: {
    position: 'absolute',
    top: 7,
    left: 7,
    maxWidth: "20%",
    color: "purple",
  },
  fab: {
    margin: 0,
    right: 0,
    bottom: 0,
    position: 'absolute',
  },
  listTitle: {
    color: '#6200EE',
    fontWeight: "bold",
  },
  subheading: {
    flex: 1,
    width: "100%",
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
  }

});

export default ShoppingScreen;